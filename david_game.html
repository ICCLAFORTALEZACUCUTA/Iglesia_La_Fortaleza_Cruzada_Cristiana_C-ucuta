<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>David y la Honda - Juego √âpico Mejorado</title>
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #A7D9EE 0%, #BFE7D3 100%);
            overflow: hidden;
            touch-action: none;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30"><circle cx="15" cy="15" r="12" stroke="%23FFD700" stroke-width="2" fill="none"/><line x1="15" y1="5" x2="15" y2="25" stroke="%23FFD700" stroke-width="2"/><line x1="5" y1="15" x2="25" y2="15" stroke="%23FFD700" stroke-width="2"/></svg>') 15 15, crosshair;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 40%, #5CB85C 100%);
            display: block;
        }

        /* UI Elements */
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            color: #FFFFFF;
            font-weight: bold;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.9);
            font-size: 1.2em;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            display: none;
            /* Hidden by default, shown when playing */
        }

        #ui div {
            margin-bottom: 5px;
        }

        #healthBar {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 220px;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            display: none;
            /* Hidden by default, shown when playing */
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #FF0000, #FFA500, #32CD32);
            transition: width 0.3s ease, background 0.5s ease;
            transform-origin: left center;
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            /* Hidden by default, shown via JS */
            z-index: 100;
        }

        #dpad {
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            float: left;
            margin-right: 20px;
        }

        .dpad-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            transition: background 0.1s, transform 0.1s, box-shadow 0.1s;
        }

        .dpad-button:active {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(0.95);
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
        }

        #up {
            top: 0;
            left: 50px;
        }

        #down {
            bottom: 0;
            left: 50px;
        }

        #left {
            top: 50px;
            left: 0;
        }

        #right {
            top: 50px;
            right: 0;
        }

        #shootButton {
            width: 80px;
            height: 80px;
            background: rgba(255, 69, 0, 0.7);
            /* Orange-red */
            border: 2px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.8);
            transition: background 0.1s, transform 0.1s, box-shadow 0.1s;
            float: right;
            margin-top: 35px;
        }

        #shootButton:active {
            background: rgba(255, 69, 0, 1);
            transform: scale(0.95);
            box-shadow: 0 0 8px rgba(255, 69, 0, 0.9);
        }

        /* Game Over & Question Modal & Start Screen */
        #gameOver,
        #questionModal,
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            z-index: 300;
            display: none;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border: 3px solid #FFD700;
        }

        #startScreen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2C003E, #000040);
            border: none;
            border-radius: 0;
            padding: 0;
        }

        #startScreen h1 {
            color: #FFD700;
            font-size: 4em;
            margin-bottom: 50px;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.9);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #questionModal {
            background: linear-gradient(135deg, #2C003E, #000040);
            border: 3px solid #FFD700;
        }

        #questionModal h2 {
            color: #FFD700;
            margin-bottom: 25px;
            font-size: 2.2em;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
        }

        #questionText {
            font-size: 20px;
            margin-bottom: 30px;
            line-height: 1.6;
            color: #E0E0E0;
        }

        .answer-button {
            display: block;
            width: 100%;
            margin: 12px 0;
            padding: 18px;
            background: linear-gradient(45deg, #1A4D2E, #2E8B57);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease, background 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        .answer-button:hover {
            background: linear-gradient(45deg, #2E8B57, #3CB371);
            transform: scale(1.02);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .answer-button.correct {
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            animation: correctAnswer 0.6s ease forwards;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }

        .answer-button.incorrect {
            background: linear-gradient(45deg, #D32F2F, #F44336);
            animation: incorrectAnswer 0.6s ease forwards;
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.8);
        }

        @keyframes correctAnswer {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.08);
                box-shadow: 0 0 30px rgba(76, 175, 80, 1);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes incorrectAnswer {

            0%,
            100% {
                transform: translateX(0);
            }

            20%,
            60% {
                transform: translateX(-8px);
            }

            40%,
            80% {
                transform: translateX(8px);
            }
        }

        /* General Button Style */
        button {
            background: linear-gradient(45deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 18px 35px;
            margin: 15px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            transform: scale(1.08);
            background: linear-gradient(45deg, #388E3C, #4CAF50);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        /* Level Text Overlay */
        #levelText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.9);
            z-index: 200;
            animation: fadeInOut 3s ease-in-out;
            pointer-events: none;
            display: none;
        }

        @keyframes fadeInOut {

            0%,
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Damage Overlay */
        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            /* Starts fully transparent */
            pointer-events: none;
            z-index: 250;
            transition: background-color 0.2s ease-out;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
                /* Flexbox for dpad and shoot button */
                justify-content: center;
                align-items: center;
                width: 90%;
                /* Adjust width */
            }

            body {
                cursor: default;
            }

            #ui {
                font-size: 1em;
                padding: 8px 12px;
            }

            #healthBar {
                width: 180px;
                height: 20px;
            }

            #levelText {
                font-size: 3em;
            }

            button {
                padding: 15px 30px;
                font-size: 16px;
            }

            #questionText {
                font-size: 18px;
            }

            .answer-button {
                font-size: 16px;
                padding: 15px;
            }

            #dpad {
                width: 120px;
                height: 120px;
                margin-right: 15px;
            }

            .dpad-button {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }

            #up {
                top: 0;
                left: 40px;
            }

            #down {
                bottom: 0;
                left: 40px;
            }

            #left {
                top: 40px;
                left: 0;
            }

            #right {
                top: 40px;
                right: 0;
            }

            #shootButton {
                width: 70px;
                height: 70px;
                font-size: 20px;
                margin-top: 25px;
            }
        }

        @media (max-width: 480px) {
            #ui {
                font-size: 0.9em;
                padding: 6px 10px;
            }

            #healthBar {
                width: 140px;
                height: 18px;
            }

            #levelText {
                font-size: 2.5em;
            }

            button {
                padding: 12px 25px;
                font-size: 14px;
            }

            #questionText {
                font-size: 16px;
            }

            .answer-button {
                font-size: 14px;
                padding: 12px;
            }

            #dpad {
                width: 100px;
                height: 100px;
                margin-right: 10px;
            }

            .dpad-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            #up {
                left: 32px;
            }

            #down {
                left: 32px;
            }

            #left {
                top: 32px;
            }

            #right {
                top: 32px;
            }

            #shootButton {
                width: 60px;
                height: 60px;
                font-size: 18px;
                margin-top: 20px;
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>Nivel: <span id="level">1</span></div>
            <div>Puntaje: <span id="score">0</span></div>
            <div>Ovejas: <span id="sheep">10</span></div>
            <div>Piedras: <span id="stones">40</span></div>
        </div>
        <div id="healthBar">
            <div id="healthFill" style="width: 100%;"></div>
        </div>
        <div id="mobileControls">
            <div id="dpad">
                <div class="dpad-button" id="up">‚Üë</div>
                <div class="dpad-button" id="down">‚Üì</div>
                <div class="dpad-button" id="left">‚Üê</div>
                <div class="dpad-button" id="right">‚Üí</div>
            </div>
            <button id="shootButton">Lanzar</button>
        </div>
        <div id="levelText"></div>
        <div id="damageOverlay"></div>
        <div id="gameOver">
            <h2>¬°Fin del Juego!</h2>
            <p id="finalScore"></p>
            <button onclick="restartGame()">Jugar de Nuevo</button>
        </div>
        <div id="questionModal">
            <h2>üìñ Pregunta B√≠blica</h2>
            <p>¬°Te has quedado sin piedras! Responde correctamente para obtener 10 m√°s.</p>
            <div id="questionText"></div>
            <div id="answers"></div>
        </div>
        <div id="startScreen">
            <h1>David y la Honda</h1>
            <button onclick="startGame()">Jugar</button>
            <button onclick="showInstructions()">Instrucciones</button>
            <button onclick="showCredits()">Cr√©ditos</button>
        </div>
    </div>

    <div id="creditsModal"
        style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:rgba(0,0,0,0.8); color:white; padding:20px; border-radius:10px; z-index:1000; text-align:center;">
        <h2>Cr√©ditos</h2>
        <p><strong>Dise√±o y Programaci√≥n:</strong> Joel Steven Pineda Rincon</p>
        <p><strong>Inspirado en:</strong> La historia b√≠blica de el Rey David.</p>
        <p><strong>Herramientas:</strong> HTML - CSS - JS</p>
        <strong>Contacto:</strong> <a href="https://wa.me/573133118664" target="_blank"
            style="color:#25D366; text-decoration:none;">3133118664</a>
        <p>¬°Gracias por jugar!</p>
        <button onclick="hideCredits()"
            style="margin-top:15px; padding:10px 20px; background-color:#4CAF50; color:white; border:none; border-radius:5px; cursor:pointer;">Cerrar</button>
    </div>

    <div id="instructionsModal"
        style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:rgba(0,0,0,0.8); color:white; padding:20px; border-radius:10px; z-index:1000; text-align:center; max-width: 80%; box-shadow: 0 0 20px rgba(0,0,0,0.5);">
        <h2>Instrucciones del Juego</h2>
        <p>Mueve a David con las teclas *WASD o las flechas.</p>
        <p>Haz clic o toca en la pantalla (o usa el bot√≥n 'Lanzar' en m√≥vil) para disparar piedras a los enemigos.
        </p>
        <p>¬°Protege tus ovejas** y tu salud!</p>
        <p>Responde preguntas b√≠blicas para obtener m√°s piedras.</p>
        <p>¬°Derrota a Goliat!</p>
        <button onclick="hideInstructions()"
            style="margin-top:20px; padding:12px 25px; background-color:#007bff; color:white; border:none; border-radius:5px; cursor:pointer; font-size:1em;">Entendido</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiDiv = document.getElementById('ui');
        const healthBarDiv = document.getElementById('healthBar');
        const mobileControlsDiv = document.getElementById('mobileControls');
        const startScreenDiv = document.getElementById('startScreen');
        const damageOverlayDiv = document.getElementById('damageOverlay');
        const shootButton = document.getElementById('shootButton');

        // --- Sound Effects (Placeholders) ---
        // REPLACE with your actual sound files. If you don't have them, the game will still run.
        const sfx = {
            shoot: new Audio('assets/sling_shot.mp3'),
            hit: new Audio('assets/enemy_hit.mp3'),
            enemyDefeat: new Audio('assets/enemy_defeat.mp3'),
            sheepLost: new Audio('assets/sheep_lost.mp3'),
            davidHit: new Audio('assets/david_hit.mp3'),
            correctAnswer: new Audio('assets/correct_answer.mp3'),
            incorrectAnswer: new Audio('assets/incorrect_answer.mp3'),
            levelUp: new Audio('assets/level_up.mp3'),
            sorcererCast: new Audio('assets/sorcerer_cast.mp3'), // New SFX
            ironGiantRoar: new Audio('assets/iron_giant_roar.mp3') // New SFX
        };

        // Set volume for all SFX (check if audio exists before setting volume)
        for (let key in sfx) {
            if (sfx[key] && typeof sfx[key].play === 'function') { // Check if it's a valid Audio object
                sfx[key].volume = 0.3; // Adjust as needed
            } else {
                // If audio file doesn't exist, create a dummy object to prevent errors
                sfx[key] = { play: () => { } };
            }
        }

        // --- Game Configuration & Initialization ---
        const GAME_CONFIG = {
            SHEEP_START: 10,
            STONES_START: 40,
            HEALTH_START: 100,
            DAVID_SPEED: 3,
            PARTICLE_COUNT_ON_HIT: 15,
            STONES_PER_QUESTION: 10,
            ENEMY_ATTACK_RANGE: 70,
            ENEMY_ATTACK_DAMAGE: 10,
            THIEF_SHEEP_STEAL_CHANCE: 0.005,
            LEVEL_UP_DELAY: 2000,
            GOLIATH_LEVEL_TRIGGER: 10, // Goliath appears from level 10 onwards
            SORCERER_PROJECTILE_SPEED: 6, // Speed of sorcerer's attack
            SORCERER_ATTACK_COOLDOWN: 180, // Frames
            DAVID_GROUND_LIMIT_Y: 0.4 // David cannot go above 40% of canvas height (from top)
        };

        let game = {
            level: 1,
            score: 0,
            sheep: GAME_CONFIG.SHEEP_START,
            stones: GAME_CONFIG.STONES_START,
            health: GAME_CONFIG.HEALTH_START,
            mouseX: 0,
            mouseY: 0,
            enemies: [],
            projectiles: [],
            particles: [],
            david: {
                x: 0,
                y: 0,
                angle: 0,
                speed: GAME_CONFIG.DAVID_SPEED,
            },
            keys: {},
            gamePaused: false,
            gameState: 'start', // 'start', 'playing', 'paused', 'gameover'
            damageOverlayAlpha: 0,
            gameTime: 0, // For day/night cycle
            levelingUp: false // New flag to prevent rapid level up
        };

        // --- Responsive Canvas Setup ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (game.david) {
                game.david.x = Math.min(Math.max(50, game.david.x), canvas.width - 50);
                game.david.y = Math.min(Math.max(canvas.height * GAME_CONFIG.DAVID_GROUND_LIMIT_Y + 30, game.david.y), canvas.height - 50);
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        game.david.x = canvas.width / 2;
        game.david.y = canvas.height - 150;

        // --- Biblical Questions ---
        const biblicalQuestions = [
            { question: "¬øCon qu√© arma derrot√≥ David a Goliat?", answers: ["Espada", "Honda", "Lanza", "Arco"], correct: 1 },
            { question: "¬øCu√°ntos d√≠as y noches llovi√≥ durante el diluvio?", answers: ["30", "40", "50", "60"], correct: 1 },
            { question: "¬øQui√©n fue el primer rey de Israel?", answers: ["David", "Salom√≥n", "Sa√∫l", "Samuel"], correct: 2 },
            { question: "¬øCu√°ntos hermanos ten√≠a Jos√©?", answers: ["10", "11", "12", "13"], correct: 1 },
            { question: "¬øEn qu√© ciudad naci√≥ Jes√∫s?", answers: ["Nazaret", "Jerusal√©n", "Bel√©n", "Capernaum"], correct: 2 },
            { question: "¬øCu√°ntos d√≠as ayun√≥ Jes√∫s en el desierto?", answers: ["30", "40", "50", "60"], correct: 1 },
            { question: "¬øQui√©n traicion√≥ a Jes√∫s?", answers: ["Pedro", "Juan", "Judas", "Tom√°s"], correct: 2 },
            { question: "¬øCu√°ntos ap√≥stoles ten√≠a Jes√∫s?", answers: ["10", "11", "12", "13"], correct: 2 },
            { question: "¬øQui√©n construy√≥ el arca?", answers: ["Abraham", "Mois√©s", "No√©", "Isaac"], correct: 2 },
            { question: "¬øEn qu√© monte recibi√≥ Mois√©s los Diez Mandamientos?", answers: ["Sina√≠", "Horeb", "Carmelo", "Si√≥n"], correct: 0 },
            { question: "¬øCu√°ntos panes y peces us√≥ Jes√∫s para alimentar a los 5000?", answers: ["3 panes y 2 peces", "5 panes y 2 peces", "7 panes y 3 peces", "2 panes y 5 peces"], correct: 1 },
            { question: "¬øQui√©n fue el padre de David?", answers: ["Isa√≠", "Samuel", "Sa√∫l", "Salom√≥n"], correct: 0 },
            { question: "¬øCu√°ntos a√±os vivi√≥ Ad√°n?", answers: ["900", "930", "950", "969"], correct: 1 },
            { question: "¬øQui√©n fue la primera mujer seg√∫n la Biblia?", answers: ["Mar√≠a", "Sara", "Eva", "Rebeca"], correct: 2 },
            { question: "¬øEn qu√© r√≠o fue bautizado Jes√∫s?", answers: ["Nilo", "Jord√°n", "Eufrates", "Tigris"], correct: 1 },
            { question: "¬øCu√°ntos libros tiene la Biblia?", answers: ["64", "66", "68", "70"], correct: 1 },
            { question: "¬øQui√©n fue el suegro de Mois√©s?", answers: ["Aar√≥n", "Jetro", "Caleb", "Josu√©"], correct: 1 },
            { question: "¬øCu√°l fue el primer milagro de Jes√∫s?", answers: ["Sanar un ciego", "Multiplicar panes", "Convertir agua en vino", "Caminar sobre el agua"], correct: 2 },
            { question: "¬øQui√©n fue el hermano de Mois√©s?", answers: ["Aar√≥n", "Caleb", "Josu√©", "Eleazar"], correct: 0 },
            { question: "¬øCu√°ntos d√≠as estuvo Jon√°s en el vientre del gran pez?", answers: ["1", "2", "3", "7"], correct: 2 }
        ];
        let usedQuestions = [];

        // --- Game Classes ---

        class Enemy {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.initialHealth = this.getHealth();
                this.health = this.initialHealth;
                this.speed = this.getSpeed();
                this.size = this.getSize();
                this.color = this.getColor();
                this.direction = Math.random() * Math.PI * 2;
                this.attackCooldown = 0;
                this.lastDamageTime = 0;
                this.specialCooldown = 0; // For sorcerer's attack
                this.vx = Math.cos(this.direction) * this.speed;
                this.vy = Math.sin(this.direction) * this.speed;
            }

            getHealth() {
                const healthMap = {
                    'thief': 1,
                    'bear': 3,
                    'lion': 3,
                    'tiger': 4,
                    'bird': 1,
                    'iron_giant': 20 + (game.level - 5) * 3, // Very high health, appears later
                    'hyena': 1, // Low health
                    'thieving_eagle': 2, // Medium health
                    'sorcerer': 5, // Medium health
                    'goliath': 15 + (game.level - GAME_CONFIG.GOLIATH_LEVEL_TRIGGER) * 2
                };
                return healthMap[this.type] || 1;
            }

            getSpeed() {
                const speedMap = {
                    'thief': 1.5,
                    'bear': 0.9,
                    'lion': 1.3,
                    'tiger': 1.7,
                    'bird': 2.5,
                    'iron_giant': 0.3, // Very slow
                    'hyena': 2.5, // Very fast
                    'thieving_eagle': 2.2, // Fast
                    'sorcerer': 0.7, // Slow, keeps distance
                    'goliath': 0.6
                };
                return speedMap[this.type] || 1;
            }

            getSize() {
                const sizeMap = {
                    'thief': 22,
                    'bear': 45,
                    'lion': 38,
                    'tiger': 38,
                    'bird': 18,
                    'iron_giant': 80, // Large
                    'hyena': 25, // Small
                    'thieving_eagle': 20, // Small to medium
                    'sorcerer': 30, // Medium
                    'goliath': 90
                };
                return sizeMap[this.type] || 20;
            }

            getColor() {
                const colorMap = {
                    'thief': '#5C4033',
                    'bear': '#7B3F00',
                    'lion': '#C2B280',
                    'tiger': '#FF9933',
                    'bird': '#4A4A4A',
                    'iron_giant': '#6C7B8B', // Steel grey
                    'hyena': '#9E9E9E', // Greyish brown
                    'thieving_eagle': '#8B4513', // Brown
                    'sorcerer': '#800080', // Purple
                    'goliath': '#A020F0'
                };
                return colorMap[this.type] || '#000000';
            }

            update() {
                this.specialCooldown--;

                // Movement logic:
                let targetX = game.david.x;
                let targetY = game.david.y;

                if (this.type === 'sorcerer') {
                    // Sorcerer tries to keep distance while facing David
                    const distanceToDavid = Math.sqrt((game.david.x - this.x) ** 2 + (game.david.y - this.y) ** 2);
                    const desiredDistance = 300; // Sorcerer's preferred attack range

                    if (distanceToDavid < desiredDistance) {
                        // Move away if too close
                        this.vx = (this.x - game.david.x) / distanceToDavid * this.speed;
                        this.vy = (this.y - game.david.y) / distanceToDavid * this.speed;
                    } else if (distanceToDavid > desiredDistance + 50) {
                        // Move closer if too far
                        this.vx = (game.david.x - this.x) / distanceToDavid * this.speed;
                        this.vy = (game.david.y - this.y) / distanceToDavid * this.speed;
                    } else {
                        // Stay put if in desired range, maybe slight random movement
                        this.vx = (Math.random() - 0.5) * 0.5;
                        this.vy = (Math.random() - 0.5) * 0.5;
                    }
                    if (this.specialCooldown <= 0) {
                        this.attack();
                        this.specialCooldown = GAME_CONFIG.SORCERER_ATTACK_COOLDOWN;
                    }

                } else if (this.type === 'thieving_eagle') {
                    // Eagle targets stones (or David if no stones left)
                    if (game.stones > 0) {
                        // Eagles fly towards David to steal stones
                        const dx = game.david.x - this.x;
                        const dy = game.david.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > this.speed) {
                            this.x += (dx / distance) * this.speed;
                            this.y += (dy / distance) * this.speed;
                        }
                        if (distance < this.size + 10 && game.stones > 0) {
                            game.stones = Math.max(0, game.stones - 1); // Steal 1 stone
                            if (sfx.sheepLost) sfx.sheepLost.play(); // Reuse sound for stone loss
                            createParticles(this.x, this.y, '#9e9e9e', 5); // Grey particles for stone
                            this.x += (this.x - game.david.x) * 0.5; // Push back eagle slightly
                            this.y += (this.y - game.david.y) * 0.5;
                        }
                    } else {
                        // If no stones, attack David directly
                        const dx = game.david.x - this.x;
                        const dy = game.david.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > this.speed) {
                            this.x += (dx / distance) * this.speed;
                            this.y += (dy / distance) * this.speed;
                        }
                    }

                } else if (this.type === 'goliath' || this.type === 'iron_giant') {
                    // Goliath and Iron Giant relentlessly pursue David
                    const dx = game.david.x - this.x;
                    const dy = game.david.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > this.speed) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    } else {
                        this.x = game.david.x;
                        this.y = game.david.y;
                    }
                } else {
                    // Normal enemies: random walk with tendency towards David/sheep
                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distanceToTarget = Math.sqrt(dx * dx + dy * dy);

                    let targetAngle = Math.atan2(dy, dx);
                    this.direction = this.direction * 0.9 + targetAngle * 0.1;

                    if (Math.random() < 0.01) {
                        this.direction += (Math.random() - 0.5) * Math.PI / 4;
                    }

                    this.vx = Math.cos(this.direction) * this.speed;
                    this.vy = Math.sin(this.direction) * this.speed;
                }

                if (this.type !== 'sorcerer') { // Sorcerer has its own velocity logic
                    this.x += this.vx;
                    this.y += this.vy;
                }


                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));

                this.attackCooldown--;
                if (this.attackCooldown <= 0 && this.type !== 'sorcerer' && this.type !== 'thieving_eagle') { // Exclude special attackers
                    this.attack();
                    this.attackCooldown = 90;
                }
            }

            attack() {
                const dx = game.david.x - this.x;
                const dy = game.david.y - this.y;
                const distanceToDavid = Math.sqrt(dx * dx + dy * dy);

                if (distanceToDavid < GAME_CONFIG.ENEMY_ATTACK_RANGE) {
                    game.health -= GAME_CONFIG.ENEMY_ATTACK_DAMAGE;
                    if (sfx.davidHit) sfx.davidHit.play();
                    navigator.vibrate(100); // Vibrate on damage
                    createParticles(game.david.x, game.david.y - 20, 'red', 15);
                    showDamageOverlay();
                }

                // Thief specific action: steal sheep
                if (this.type === 'thief' && game.sheep > 0 && Math.random() < GAME_CONFIG.THIEF_SHEEP_STEAL_CHANCE) {
                    game.sheep--;
                    if (sfx.sheepLost) sfx.sheepLost.play();
                    createParticles(this.x, this.y, '#F5F5F5', 10);
                }

                // Sorcerer specific ranged attack
                if (this.type === 'sorcerer' && this.specialCooldown <= 0) {
                    game.projectiles.push(new Projectile(this.x, this.y, game.david.x, game.david.y, 1, 'magic')); // Magic projectile
                    if (sfx.sorcererCast) sfx.sorcererCast.play();
                    this.specialCooldown = GAME_CONFIG.SORCERER_ATTACK_COOLDOWN;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Simple Shadow beneath enemy
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.size * 0.8, this.size * 0.9, this.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Visual damage feedback (red tint)
                const damageAlpha = (Date.now() - this.lastDamageTime < 150) ? 0.7 : 0;
                if (damageAlpha > 0) {
                    ctx.globalAlpha = damageAlpha;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Draw based on type
                if (this.type === 'goliath') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size / 2, -this.size * 1.2, this.size, this.size * 2.4);

                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect(-this.size / 2, -this.size * 1.2, this.size, this.size * 0.3);
                    ctx.fillRect(-this.size / 2, -this.size * 0.3, this.size, this.size * 0.6);

                    ctx.beginPath();
                    ctx.arc(-this.size / 2, -this.size * 0.7, this.size / 2, Math.PI / 2, Math.PI * 1.5);
                    ctx.arc(this.size / 2, -this.size * 0.7, this.size / 2, Math.PI * 1.5, Math.PI / 2);
                    ctx.fill();

                    ctx.fillStyle = '#696969';
                    ctx.fillRect(this.size / 2, -this.size, 5, -this.size * 0.5);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(this.size / 2 + 2.5, -this.size * 1.5);
                    ctx.lineTo(this.size / 2 + 10, -this.size * 1.4);
                    ctx.lineTo(this.size / 2 - 5, -this.size * 1.4);
                    ctx.closePath();
                    ctx.fill();

                } else if (this.type === 'iron_giant') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size / 2, -this.size * 0.9, this.size, this.size * 1.8); // Body
                    ctx.fillStyle = '#A9A9A9'; // Darker metal
                    ctx.fillRect(-this.size / 2 + 5, -this.size * 0.8, this.size - 10, this.size * 1.6); // Inner plating
                    ctx.beginPath(); // Head
                    ctx.arc(0, -this.size, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath(); // Shoulders
                    ctx.arc(-this.size * 0.6, -this.size * 0.6, this.size * 0.4, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.6, -this.size * 0.6, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();

                } else if (this.type === 'hyena') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 1.2, this.size * 0.8, 0, 0, Math.PI * 2); // Body
                    ctx.fill();
                    ctx.fillStyle = '#A0522D'; // Brown spots
                    ctx.beginPath();
                    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
                    ctx.arc(10, 5, 3, 0, Math.PI * 2);
                    ctx.arc(-15, 10, 3, 0, Math.PI * 2);
                    ctx.fill();

                } else if (this.type === 'thieving_eagle') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2); // Body
                    ctx.fill();
                    ctx.fillStyle = '#FFD700'; // Beak
                    ctx.beginPath();
                    ctx.moveTo(this.size, 0);
                    ctx.lineTo(this.size + 8, -5);
                    ctx.lineTo(this.size + 8, 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = this.color; // Wings
                    ctx.beginPath();
                    ctx.ellipse(-this.size / 2, -this.size * 0.8, this.size * 0.8, this.size * 0.3, -Math.PI / 4, 0, Math.PI * 2);
                    ctx.ellipse(this.size / 2, -this.size * 0.8, this.size * 0.8, this.size * 0.3, Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill();
                    // Holding icon for stones
                    ctx.fillStyle = '#9e9e9e';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.5, this.size * 0.5, 5, 0, Math.PI * 2);
                    ctx.fill();

                } else if (this.type === 'sorcerer') {
                    ctx.fillStyle = this.color; // Robes
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#D3D3D3'; // Staff
                    ctx.fillRect(this.size, -this.size * 1.5, 5, this.size * 3);
                    ctx.fillStyle = '#FFD700'; // Orb
                    ctx.beginPath();
                    ctx.arc(this.size + 2.5, -this.size * 1.5, 8, 0, Math.PI * 2);
                    ctx.fill();

                } else if (this.type === 'bird') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(this.size, 0);
                    ctx.lineTo(this.size + 8, -5);
                    ctx.lineTo(this.size + 8, 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(-this.size / 2, -this.size * 0.8, this.size * 0.8, this.size * 0.3, -Math.PI / 4, 0, Math.PI * 2);
                    ctx.ellipse(this.size / 2, -this.size * 0.8, this.size * 0.8, this.size * 0.3, Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill();

                } else if (this.type === 'thief') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, Math.PI, 0);
                    ctx.rect(-this.size, -this.size * 0.8, this.size * 2, this.size * 1.6);
                    ctx.fill();
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.8, this.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#4A2B1A';
                    ctx.fillRect(this.size * 0.8, -this.size * 0.5, this.size * 0.6, this.size * 0.8);

                } else if (this.type === 'lion') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 1.2, this.size, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#B8860B';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.3, -this.size * 0.2, 2, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.3, -this.size * 0.2, 2, 0, Math.PI * 2);
                    ctx.fill();

                } else if (this.type === 'tiger') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 1.2, this.size, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.fillRect(-this.size * 0.8, -this.size * 0.5, 5, this.size);
                    ctx.fillRect(-this.size * 0.4, -this.size * 0.8, 5, this.size * 1.5);
                    ctx.fillRect(this.size * 0.2, -this.size * 0.6, 5, this.size * 1.2);
                    ctx.fillRect(this.size * 0.6, -this.size * 0.3, 5, this.size);

                } else if (this.type === 'bear') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.8, this.size * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.5, -this.size * 1.2, this.size * 0.3, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.5, -this.size * 1.2, this.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (this.health < this.initialHealth) {
                    const barWidth = this.size * 1.5;
                    const barHeight = 7;
                    const barYOffset = this.size + 15;
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(-barWidth / 2, -barYOffset, barWidth, barHeight);
                    ctx.fillStyle = 'rgb(50,205,50)';
                    ctx.fillRect(-barWidth / 2, -barYOffset, (barWidth * this.health) / this.initialHealth, barHeight);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-barWidth / 2, -barYOffset, barWidth, barHeight);
                }

                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, targetX, targetY, power, type = 'stone') {
                this.x = x;
                this.y = y;
                this.power = power;
                this.speed = 8; // Fixed speed for direct launch
                if (type === 'magic') this.speed = GAME_CONFIG.SORCERER_PROJECTILE_SPEED;

                this.type = type; // 'stone' or 'magic' (for sorcerer)

                const angle = Math.atan2(targetY - y, targetX - x);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;

                this.size = type === 'magic' ? 10 : 8; // Fixed size for direct launch
                this.life = 120;
                this.trail = [];
            }

            update() {
                this.trail.unshift({ x: this.x, y: this.y, size: this.size });
                if (this.trail.length > 5) {
                    this.trail.pop();
                }

                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                if (this.type === 'stone') {
                    for (let i = game.enemies.length - 1; i >= 0; i--) {
                        const enemy = game.enemies[i];
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < enemy.size + this.size) {
                            enemy.health -= this.power;
                            enemy.lastDamageTime = Date.now();
                            if (sfx.hit) sfx.hit.play();
                            createParticles(this.x, this.y, '#FFD700', GAME_CONFIG.PARTICLE_COUNT_ON_HIT);

                            if (enemy.health <= 0) {
                                game.enemies.splice(i, 1);
                                game.score += enemy.type === 'goliath' ? 2500 : (enemy.type === 'iron_giant' ? 1000 : 150);
                                if (sfx.enemyDefeat) sfx.enemyDefeat.play();
                                createParticles(enemy.x, enemy.y, enemy.color, GAME_CONFIG.PARTICLE_COUNT_ON_HIT * 2);
                            }
                            return false;
                        }
                    }
                } else if (this.type === 'magic') {
                    // Magic projectile from sorcerer hits David
                    const dx = this.x - game.david.x;
                    const dy = this.y - game.david.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 30 + this.size) { // David's approximate size + projectile size
                        game.health -= 20; // Magic attack deals more damage
                        if (sfx.davidHit) sfx.davidHit.play();
                        navigator.vibrate(150); // Stronger vibrate for magic damage
                        createParticles(game.david.x, game.david.y - 20, '#00FFFF', 20); // Cyan particles for magic hit
                        showDamageOverlay();
                        return false; // Projectile disappears on hit
                    }
                }

                return this.life > 0 && this.x > -50 && this.x < canvas.width + 50 && this.y > -50 && this.y < canvas.height + 50;
            }

            draw() {
                for (let i = 0; i < this.trail.length; i++) {
                    const trailPart = this.trail[i];
                    const alpha = (this.trail.length - i) / this.trail.length;
                    ctx.fillStyle = this.type === 'magic' ? `rgba(0, 255, 255, ${alpha * 0.5})` : `rgba(139, 69, 19, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(trailPart.x, trailPart.y, trailPart.size * (alpha * 0.5 + 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = this.type === 'magic' ? '#00FFFF' : '#8B4513';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color, type = 'normal') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 12;
                this.vy = (Math.random() - 0.5) * 12;
                this.color = color;
                this.life = 45;
                this.size = Math.random() * 6 + 3;
                this.gravity = 0.3;
                this.type = type;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life--;
                this.size *= 0.96;
                this.vx *= 0.98;
                this.vy *= 0.98;
                return this.life > 0 && this.size > 0.5;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 45;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                game.particles.push(new Particle(x, y, color));
            }
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.3; // Upper part of the sky
                this.size = Math.random() * 80 + 50;
                this.speed = Math.random() * 0.3 + 0.1;
                this.color = 'rgba(255, 255, 255, 0.7)';
            }

            update() {
                this.x += this.speed;
                if (this.x > canvas.width + this.size) {
                    this.x = -this.size; // Reset off-screen left
                    this.y = Math.random() * canvas.height * 0.3; // New random height
                    this.size = Math.random() * 80 + 50;
                    this.speed = Math.random() * 0.3 + 0.1;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.6, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.7, this.y - this.size * 0.2, this.size * 0.5, 0, Math.PI * 2);
                ctx.arc(this.x - this.size * 0.8, this.y + this.size * 0.1, this.size * 0.6, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.2, this.y + this.size * 0.4, this.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        let clouds = [];
        for (let i = 0; i < 5; i++) { // 5 clouds
            clouds.push(new Cloud());
        }

        // --- Game Drawing Functions ---

        function drawGroundTexture() {
            const textureSize = 50;
            for (let x = 0; x < canvas.width; x += textureSize) {
                for (let y = canvas.height * 0.4; y < canvas.height; y += textureSize) {
                    ctx.fillStyle = (x / textureSize + y / textureSize) % 2 === 0 ? '#5CB85C' : '#4CAF50';
                    ctx.fillRect(x, y, textureSize, textureSize);
                }
            }
        }

        // Bushes have fixed positions now
        const bushPositions = [];
        const numBushes = 25;
        for (let i = 0; i < numBushes; i++) {
            const x = (i * 73 + 123) % canvas.width;
            const y = canvas.height * 0.4 + (i * 97 + 103) % (canvas.height * 0.6 - 80);
            const size = 20 + Math.random() * 30;
            bushPositions.push({ x, y, size });
        }

        function drawBushes() {
            const bushColor = '#2E8B57';
            const bushOutline = '#1A532C';
            bushPositions.forEach(bush => {
                const { x, y, size } = bush;

                ctx.fillStyle = bushColor;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = bushColor;
                ctx.beginPath();
                ctx.arc(x + size * 0.6, y - size * 0.4, size * 0.7, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = bushColor;
                ctx.beginPath();
                ctx.arc(x - size * 0.5, y + size * 0.3, size * 0.8, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = bushOutline;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.arc(x + size * 0.6, y - size * 0.4, size * 0.7, 0, Math.PI * 2);
                ctx.arc(x - size * 0.5, y + size * 0.3, size * 0.8, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function drawDavid() {
            ctx.save();
            ctx.translate(game.david.x, game.david.y);

            // Simple Shadow beneath David
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 30, 25, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(-20, -30);
            ctx.lineTo(20, -30);
            ctx.lineTo(15, 30);
            ctx.lineTo(-15, 30);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#2F4F4F';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#FDBCB4';
            ctx.beginPath();
            ctx.arc(0, -45, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(0, -50, 18, 0, Math.PI, true);
            ctx.lineTo(0, -45);
            ctx.fill();

            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-7, -48, 2, 0, Math.PI * 2);
            ctx.arc(7, -48, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, -40, 5, 0, Math.PI);
            ctx.stroke();

            ctx.fillStyle = '#FDBCB4';
            ctx.fillRect(-28, -25, 10, 30);
            ctx.fillRect(18, -25, 10, 30);

            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;

            // Simplified sling drawing
            ctx.beginPath();
            ctx.moveTo(-20, -15);
            ctx.lineTo(20, -15);
            ctx.stroke();
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-20, -15);
            ctx.lineTo(20, -15);
            ctx.stroke();
            ctx.fillStyle = '#696969';
            ctx.beginPath();
            ctx.arc(0, -15, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FDBCB4';
            ctx.fillRect(-10, 30, 8, 20);
            ctx.fillRect(2, 30, 8, 20);

            ctx.fillStyle = '#654321';
            ctx.fillRect(-12, 50, 12, 8);
            ctx.fillRect(0, 50, 12, 8);

            ctx.restore();
        }

        function drawSheep() {
            const sheepSpacingX = 45;
            const sheepSpacingY = 35;
            const startX = 60;
            const startY = canvas.height - 70;

            for (let i = 0; i < game.sheep; i++) {
                const x = startX + (i % 10) * sheepSpacingX;
                const y = startY - Math.floor(i / 10) * sheepSpacingY;

                ctx.save();
                ctx.translate(x, y);

                ctx.fillStyle = '#F5F5DC';
                ctx.beginPath();
                ctx.arc(0, 0, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#D3D3D3';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(10, -15, 8, 0, Math.PI * 2);
                ctx.arc(-10, -12, 7, 0, Math.PI * 2);
                ctx.arc(0, 15, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#36454F';
                ctx.beginPath();
                ctx.arc(-15, -5, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(-20, -10);
                ctx.lineTo(-28, -15);
                ctx.lineTo(-20, -20);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(-10, -10);
                ctx.lineTo(-2, -15);
                ctx.lineTo(-10, -20);
                ctx.fill();

                ctx.fillStyle = '#36454F';
                ctx.fillRect(-10, 12, 5, 15);
                ctx.fillRect(5, 12, 5, 15);
                ctx.fillRect(-10, 12, 5, 15);
                ctx.fillRect(5, 12, 5, 15);

                ctx.restore();
            }
        }

        // --- Lighting and Time of Day ---
        function applyLighting() {
            game.gameTime = (game.gameTime + 0.0005) % (Math.PI * 2); // Cycle every ~2 hours of game time
            const timeOfDay = Math.sin(game.gameTime); // -1 (night) to 1 (midday)

            let alpha = 1.0;
            let skyColor1 = '#87CEEB'; // Midday blue
            let skyColor2 = '#98FB98'; // Midday green
            let grassColor1 = '#5CB85C';
            let grassColor2 = '#4CAF50';

            if (timeOfDay < -0.8) { // Deep Night
                alpha = 0.3;
                skyColor1 = '#000033';
                skyColor2 = '#000000';
                grassColor1 = '#001a00';
                grassColor2 = '#002600';
            } else if (timeOfDay < -0.3) { // Night
                alpha = 0.5 + (0.5 * (timeOfDay + 0.3));
                skyColor1 = `rgb(0,0,${Math.floor(51 + timeOfDay * 50)})`;
                skyColor2 = `rgb(0,0,${Math.floor(20 + timeOfDay * 40)})`;
                grassColor1 = `rgb(0,${Math.floor(26 + timeOfDay * 20)},0)`;
                grassColor2 = `rgb(0,${Math.floor(38 + timeOfDay * 20)},0)`;
            } else if (timeOfDay < 0.2) { // Dawn/Dusk
                alpha = 0.7 + (0.3 * timeOfDay / 0.2);
                skyColor1 = `rgb(${Math.floor(255 * (0.5 + timeOfDay * 2))},${Math.floor(100 + timeOfDay * 300)},${Math.floor(100 + timeOfDay * 300)})`; // Orange-pink
                skyColor2 = `rgb(${Math.floor(255 * (0.3 + timeOfDay * 2))},${Math.floor(50 + timeOfDay * 200)},${Math.floor(50 + timeOfDay * 200)})`;
                grassColor1 = `rgb(${Math.floor(92 + timeOfDay * 100)},${Math.floor(184 + timeOfDay * 100)},${Math.floor(92 + timeOfDay * 100)})`;
                grassColor2 = `rgb(${Math.floor(76 + timeOfDay * 100)},${Math.floor(175 + timeOfDay * 100)},${Math.floor(76 + timeOfDay * 100)})`;
            } else { // Day
                alpha = 1.0;
                skyColor1 = '#87CEEB';
                skyColor2 = '#98FB98';
                grassColor1 = '#5CB85C';
                grassColor2 = '#4CAF50';
            }

            canvas.style.background = `linear-gradient(to bottom, ${skyColor1} 0%, ${skyColor2} 40%, ${grassColor1} 100%)`;
            // Store grass colors for drawGroundTexture
            game.currentGrassColor1 = grassColor1;
            game.currentGrassColor2 = grassColor2;
            ctx.globalAlpha = alpha; // Overall transparency for night
        }

        // Modified drawGroundTexture to use dynamic colors
        function drawGroundTexture() {
            const textureSize = 50;
            for (let x = 0; x < canvas.width; x += textureSize) {
                for (let y = canvas.height * 0.4; y < canvas.height; y += textureSize) {
                    ctx.fillStyle = (x / textureSize + y / textureSize) % 2 === 0 ? game.currentGrassColor1 : game.currentGrassColor2;
                    ctx.fillRect(x, y, textureSize, textureSize);
                }
            }
        }

        // --- UI & Game State Management ---
        function updateUI() {
            document.getElementById('level').textContent = game.level;
            document.getElementById('score').textContent = game.score;
            document.getElementById('sheep').textContent = game.sheep;
            document.getElementById('stones').textContent = game.stones;

            const healthFill = document.getElementById('healthFill');
            healthFill.style.width = game.health + '%';
            if (game.health > 60) {
                healthFill.style.background = 'linear-gradient(90deg, #32CD32, #4CAF50)';
            } else if (game.health > 30) {
                healthFill.style.background = 'linear-gradient(90deg, #FFA500, #FFD700)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #FF0000, #DC143C)';
            }
        }

        function checkLevelComplete() {
            // Only level up if playing, not already leveling up, and no enemies left
            if (game.enemies.length === 0 && game.gameState === 'playing' && !game.levelingUp) {
                game.levelingUp = true; // Set flag to prevent multiple triggers
                game.level++;
                if (sfx.levelUp) sfx.levelUp.play();
                showLevelText(`¬°Nivel ${game.level}!`);
                console.log(`Leveling up to: ${game.level}`); // Debugging line
                setTimeout(() => {
                    spawnEnemies();
                    game.levelingUp = false; // Reset flag after enemies are spawned
                }, GAME_CONFIG.LEVEL_UP_DELAY);
            }
        }

        function showLevelText(text) {
            const levelTextEl = document.getElementById('levelText');
            levelTextEl.textContent = text;
            levelTextEl.style.display = 'block';
            setTimeout(() => {
                levelTextEl.style.display = 'none';
            }, 3000);
        }

        function showDamageOverlay() {
            game.damageOverlayAlpha = 0.3; // Start with 30% opaque red
            damageOverlayDiv.style.backgroundColor = `rgba(255, 0, 0, ${game.damageOverlayAlpha})`;
            setTimeout(() => {
                game.damageOverlayAlpha = 0; // Fade out
                damageOverlayDiv.style.backgroundColor = `rgba(255, 0, 0, ${game.damageOverlayAlpha})`;
            }, 200); // Quick flash
        }

        function showQuestion() {
            game.gameState = 'paused'; // Pause game logic
            document.getElementById('questionModal').style.display = 'block';

            if (usedQuestions.length === biblicalQuestions.length) {
                usedQuestions = [];
            }

            let availableQuestions = biblicalQuestions.filter((_, index) => !usedQuestions.includes(index));
            let randomIndex = Math.floor(Math.random() * availableQuestions.length);
            let questionData = availableQuestions[randomIndex];
            let questionIndex = biblicalQuestions.indexOf(questionData);

            usedQuestions.push(questionIndex);

            document.getElementById('questionText').textContent = questionData.question;

            let answersDiv = document.getElementById('answers');
            answersDiv.innerHTML = '';

            questionData.answers.forEach((answer, index) => {
                let button = document.createElement('button');
                button.textContent = answer;
                button.className = 'answer-button';
                button.onclick = () => checkAnswer(index, questionData.correct, button);
                answersDiv.appendChild(button);
            });
        }

        function checkAnswer(selected, correct, button) {
            let buttons = document.querySelectorAll('.answer-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                button.classList.add('correct');
                if (sfx.correctAnswer) sfx.correctAnswer.play();
                game.stones += GAME_CONFIG.STONES_PER_QUESTION;
                setTimeout(() => {
                    document.getElementById('questionModal').style.display = 'none';
                    buttons.forEach(btn => {
                        btn.disabled = false;
                        btn.classList.remove('correct', 'incorrect');
                    });
                    game.gameState = 'playing'; // Resume game
                }, 1000);
            } else {
                button.classList.add('incorrect');
                buttons[correct].classList.add('correct');
                if (sfx.incorrectAnswer) sfx.incorrectAnswer.play();
                setTimeout(() => {
                    document.getElementById('questionModal').style.display = 'none';
                    buttons.forEach(btn => {
                        btn.disabled = false;
                        btn.classList.remove('correct', 'incorrect');
                    });
                    game.gameState = 'playing'; // Resume game even if wrong
                }, 2000);
            }
        }

        function spawnEnemies() {
            let spawnCount = Math.min(game.level * 2 + 3, 20); // Scale up enemy count, max 20 per wave

            for (let i = 0; i < spawnCount; i++) {
                let type;
                // Determine enemy type based on level
                if (game.level < 2) {
                    type = 'thief';
                } else if (game.level < 4) {
                    type = Math.random() < 0.7 ? 'thief' : ['bear', 'lion'][Math.floor(Math.random() * 2)];
                } else if (game.level < 6) {
                    type = ['thief', 'bear', 'lion', 'tiger', 'bird'][Math.floor(Math.random() * 5)];
                    if (Math.random() < 0.2 && game.level >= 5) type = 'hyena'; // Introduce hyenas
                } else if (game.level < 8) {
                    type = ['thief', 'bear', 'lion', 'tiger', 'bird', 'hyena'][Math.floor(Math.random() * 6)];
                    if (Math.random() < 0.15) type = 'thieving_eagle'; // Introduce thieving eagles
                } else if (game.level < GAME_CONFIG.GOLIATH_LEVEL_TRIGGER) { // Levels 8 & 9
                    type = ['thief', 'bear', 'lion', 'tiger', 'bird', 'hyena', 'thieving_eagle'][Math.floor(Math.random() * 7)];
                    if (Math.random() < 0.1) type = 'sorcerer'; // Introduce sorcerer
                    if (Math.random() < 0.05) type = 'iron_giant'; // Introduce iron giant
                } else { // From Goliath trigger level onwards
                    if (game.level === GAME_CONFIG.GOLIATH_LEVEL_TRIGGER && i === 0) { // Ensure one Goliath on trigger level
                        type = 'goliath';
                    } else if (game.level > GAME_CONFIG.GOLIATH_LEVEL_TRIGGER && Math.random() < 0.05 + (game.level - GAME_CONFIG.GOLIATH_LEVEL_TRIGGER) * 0.01) {
                        type = 'goliath'; // Small chance for Goliath to reappear
                    } else {
                        // Mix of all enemies after Goliath
                        type = ['thief', 'bear', 'lion', 'tiger', 'bird', 'hyena', 'thieving_eagle', 'sorcerer', 'iron_giant'][Math.floor(Math.random() * 9)];
                    }
                }

                // Spawn enemies off-screen near edges
                let x, y;
                const side = Math.floor(Math.random() * 4);
                const spawnOffset = 50;

                switch (side) {
                    case 0: x = Math.random() * canvas.width; y = -spawnOffset; break;
                    case 1: x = canvas.width + spawnOffset; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height + spawnOffset; break; // Allow some bottom spawns
                    case 3: x = -spawnOffset; y = Math.random() * canvas.height; break;
                }

                game.enemies.push(new Enemy(type, x, y));
                if (type === 'hyena' && Math.random() < 0.5) { // Spawn hyenas in pairs/triplets
                    game.enemies.push(new Enemy('hyena', x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 50));
                }
            }
        }

        function gameOver() {
            game.gameState = 'gameover';
            document.getElementById('finalScore').textContent = `Puntaje Final: ${game.score}`;
            document.getElementById('gameOver').style.display = 'block';
            uiDiv.style.display = 'none';
            healthBarDiv.style.display = 'none';
            mobileControlsDiv.style.display = 'none';
        }

        function restartGame() {
            game.level = 1;
            game.score = 0;
            game.sheep = GAME_CONFIG.SHEEP_START;
            game.stones = GAME_CONFIG.STONES_START;
            game.health = GAME_CONFIG.HEALTH_START;
            game.enemies = [];
            game.projectiles = [];
            game.particles = [];
            game.david.x = canvas.width / 2;
            game.david.y = canvas.height - 150;
            game.david.charging = false;
            game.david.chargeTime = 0;
            usedQuestions = [];
            game.gameTime = 0; // Reset time of day
            game.levelingUp = false; // Reset flag

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('questionModal').style.display = 'none';

            startGame(); // Go back to the game playing state
        }

        function startGame() {
            startScreenDiv.style.display = 'none';
            uiDiv.style.display = 'block';
            healthBarDiv.style.display = 'block';
            if (window.matchMedia("(pointer: coarse)").matches) { // Show mobile controls if touch device
                mobileControlsDiv.style.display = 'flex';
            }
            game.gameState = 'playing';
            spawnEnemies();
            if (!gameLoopStarted) { // Prevent multiple game loops
                requestAnimationFrame(gameLoop);
                gameLoopStarted = true;
            }
        }

        function showInstructions() {
            const instructionsModal = document.getElementById('instructionsModal');
            instructionsModal.style.display = 'block'; // Hace el modal visible
            setTimeout(() => { // Peque√±o retraso para que la transici√≥n CSS se active
                instructionsModal.classList.add('show');
            }, 10);
        }

        function hideInstructions() {
            const instructionsModal = document.getElementById('instructionsModal');
            instructionsModal.classList.remove('show'); // Inicia la animaci√≥n de salida
            setTimeout(() => { // Retrasa la ocultaci√≥n hasta que la animaci√≥n termine
                instructionsModal.style.display = 'none';
            }, 300); // Este valor debe coincidir con la duraci√≥n de la transici√≥n CSS (0.3s)
        }

        // Tus otras funciones (como showCredits, si las tienes)
        function showCredits() {
            const creditsModal = document.getElementById('creditsModal');
            creditsModal.style.display = 'block';
            setTimeout(() => {
                creditsModal.classList.add('show');
            }, 10);
        }

        function hideCredits() {
            const creditsModal = document.getElementById('creditsModal');
            creditsModal.classList.remove('show');
            setTimeout(() => {
                creditsModal.style.display = 'none';
            }, 300);
        }

        // --- David Movement Update Function ---
        function updateDavidMovement() {
            const david = game.david;
            const speed = david.speed;
            const size = 30; // David's approximate size

            if (game.keys['arrowup'] || game.keys['w']) {
                david.y -= speed;
            }
            if (game.keys['arrowdown'] || game.keys['s']) {
                david.y += speed;
            }
            if (game.keys['arrowleft'] || game.keys['a']) {
                david.x -= speed;
            }
            if (game.keys['arrowright'] || game.keys['d']) {
                david.x += speed;
            }

            // Boundary checks
            david.x = Math.max(size, Math.min(canvas.width - size, david.x));
            // Restrict David's Y movement to the ground area
            david.y = Math.max(canvas.height * GAME_CONFIG.DAVID_GROUND_LIMIT_Y + size, Math.min(canvas.height - size, david.y));
        }

        // --- Main Game Loop ---
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        let gameLoopStarted = false; // Flag to ensure only one loop is active

        function gameLoop(timestamp) {
            if (game.gameState === 'paused' || game.gameState === 'gameover') {
                requestAnimationFrame(gameLoop);
                return;
            }

            const elapsed = timestamp - lastFrameTime;

            if (elapsed < frameInterval) {
                requestAnimationFrame(gameLoop);
                return;
            }

            lastFrameTime = timestamp - (elapsed % frameInterval);

            // Apply lighting and clear canvas
            applyLighting();
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear after lighting for new colors to apply

            // Draw background elements first for layering
            drawGroundTexture();
            drawBushes();
            clouds.forEach(cloud => {
                cloud.update();
                cloud.draw();
            });

            // Update David's angle towards mouse
            const dx = game.mouseX - game.david.x;
            const dy = game.mouseY - game.david.y;
            game.david.angle = Math.atan2(dy, dx);

            // Update & Draw Game Entities
            updateDavidMovement();
            game.enemies.forEach(enemy => enemy.update());
            game.projectiles = game.projectiles.filter(projectile => projectile.update());
            game.particles = game.particles.filter(particle => particle.update());

            drawSheep();
            drawDavid();
            game.enemies.forEach(enemy => enemy.draw());
            game.projectiles.forEach(projectile => projectile.draw());
            game.particles.forEach(particle => particle.draw());

            // UI & Game State Checks
            updateUI();
            checkLevelComplete(); // Will not trigger if levelingUp is true

            if (game.health <= 0 || game.sheep <= 0) {
                gameOver();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });

        // Click/Tap to shoot (simplified)
        canvas.addEventListener('mousedown', (e) => {
            if (game.gameState === 'playing' && e.button === 0 && game.stones > 0) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const power = 1.5; // Fixed power for direct launch
                game.projectiles.push(new Projectile(game.david.x, game.david.y, mouseX, mouseY, power));
                game.stones--;
                if (sfx.shoot) sfx.shoot.play();
                navigator.vibrate(50); // Vibrate on shoot

                if (game.stones === 0) {
                    setTimeout(() => {
                        showQuestion();
                    }, 500);
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouseX = e.clientX - rect.left;
            game.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Mobile Controls ---
        function setupMobileControls() {
            if (window.matchMedia("(pointer: coarse)").matches) {
                mobileControlsDiv.style.display = 'flex'; // Show controls
            }

            const buttons = ['up', 'down', 'left', 'right'];

            buttons.forEach(direction => {
                const button = document.getElementById(direction);

                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (game.gameState === 'playing') {
                        // Use generic keys which are then mapped to specific actions
                        switch (direction) {
                            case 'up': game.keys['w'] = true; break; // Map to 'w' for consistent movement
                            case 'down': game.keys['s'] = true; break;
                            case 'left': game.keys['a'] = true; break;
                            case 'right': game.keys['d'] = true; break;
                        }
                    }
                }, { passive: false });

                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    switch (direction) {
                        case 'up': game.keys['w'] = false; break;
                        case 'down': game.keys['s'] = false; break;
                        case 'left': game.keys['a'] = false; break;
                        case 'right': game.keys['d'] = false; break;
                    }
                });
            });

            // Mobile shoot button (simplified)
            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.gameState === 'playing' && game.stones > 0) {
                    // For mobile shoot, target is assumed to be roughly in front of David or at last known touch
                    // If no mouseX/Y from touch, default to center of canvas
                    const targetX = game.mouseX || canvas.width / 2;
                    const targetY = game.mouseY || canvas.height / 2;

                    const power = 1.5; // Fixed power
                    game.projectiles.push(new Projectile(game.david.x, game.david.y, targetX, targetY, power));
                    game.stones--;
                    if (sfx.shoot) sfx.shoot.play();
                    navigator.vibrate(50); // Vibrate on shoot

                    if (game.stones === 0) {
                        setTimeout(() => {
                            showQuestion();
                        }, 500);
                    }
                }
            }, { passive: false });

            // Listen for touch on canvas to update mouseX/Y for aim on mobile
            canvas.addEventListener('touchstart', (e) => {
                // Check if touch is not on a d-pad button or shoot button
                if (e.touches.length === 1 && game.gameState === 'playing' && !e.target.closest('.dpad-button') && e.target !== shootButton) {
                    e.preventDefault(); // Prevent scrolling
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    game.mouseX = touch.clientX - rect.left;
                    game.mouseY = touch.clientY - rect.top;
                    // Also trigger a shot on touch
                    if (game.stones > 0) {
                        const power = 1.5; // Fixed power
                        game.projectiles.push(new Projectile(game.david.x, game.david.y, game.mouseX, game.mouseY, power));
                        game.stones--;
                        if (sfx.shoot) sfx.shoot.play();
                        navigator.vibrate(50);
                        if (game.stones === 0) {
                            setTimeout(() => {
                                showQuestion();
                            }, 500);
                        }
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                // Update aim while dragging if not on controls
                if (e.touches.length === 1 && game.gameState === 'playing' && !e.target.closest('.dpad-button') && e.target !== shootButton) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    game.mouseX = touch.clientX - rect.left;
                    game.mouseY = touch.clientY - rect.top;
                }
            }, { passive: false });

        }

        // --- Initialization ---
        setupMobileControls();
        // The game starts with the start screen, gameLoop will be called when 'Jugar' is clicked.
        // No need to call spawnEnemies() or gameLoop() directly here anymore.
    </script>
</body>

</html>